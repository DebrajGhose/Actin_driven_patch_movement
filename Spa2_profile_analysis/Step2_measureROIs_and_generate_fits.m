%% Measure Spa2 patch profilies. Takes points that you have marked out earlier, and draws a) a vertical line b) a horizontal
% line through the point. Measure intensties along those two lines so that
% you can fit and average.

clear all
close all

pixtomic = 0.1386;
linedraw = 15; %measurement line that you want to draw
alllines = []; %matrix of all measured intensities

load('AllMyROIs.mat');

filename2 = 'C2-20160206_PDGGTexp3_dly18172_dly18274_alpha0nM_488_561_merged.tif'; %red channel
im2 = imread(filename2);

%im2 = imadjust(im2);
%imagesc(im2)

for i = 1:numel(myROIs)
    
    rangex = [ round(myROIs{i}(1)-linedraw) : round(myROIs{i}(1)+linedraw) ]; %draw horizontal and vertical lines you want to measure along
    rangey = [ round(myROIs{i}(2)-linedraw) : round(myROIs{i}(2)+linedraw) ];
    
    distance = [1:numel(rangex)];
    
    %Sweep along the x and y direction and choose 
    squareregion = im2(rangey,rangex);
    [~,MaxCol] = max(sum(squareregion,1)); [~,MaxRow] = max(sum(squareregion,2));
    
    xint = squareregion( MaxRow , :); %swap x and y with row and column
    yint = squareregion( : , MaxCol ); %swap x and y with row and column
    
    alllines = [alllines ; xint ; yint' ] ; % stack all measure intensities into this matrix
    
end



%{

for i = 1:numel(myROIs)
    
    rangex = [ round(myROIs{i}(1)-linedraw) : round(myROIs{i}(1)+linedraw) ]; %draw horizontal and vertical lines you want to measure along
    rangey = [ round(myROIs{i}(2)-linedraw) : round(myROIs{i}(2)+linedraw) ];
    
    distance = [1:numel(rangex)];
    
    xint = im2( round(myROIs{i}(2)) , rangex); %swap x and y with row and column
    yint = im2( rangey , round(myROIs{i}(1))); %swap x and y with row and column
    
    alllines = [alllines ; xint ; yint' ] ; % stack all measure intensities into this matrix
    
end

%}

%% do fits

alignedthings = zeros(size(alllines,1),40);

allmeans = [];

for i = 1:size(alllines,1)
    
    subplot(8,5,i)
    
    [fitresult,gof] = createFit(distance,alllines(i,:));
    midpoint = round(fitresult.u);
    alignedthings( i , 15:35 ) = alllines( i , (midpoint-10):(midpoint+10));
    
end
fitresult %debug
alignedthings = alignedthings(:,15:35); %concatenate alignedthings and then normalize between 0 to 1000

% optional -- normalize everything
%for i = 1:size(alignedthings,1), alignedthings(i,:) = 1000*( alignedthings(i,:) - min(alignedthings(i,:)) )./( max(alignedthings(i,:)) - min(alignedthings(i,:)) );   end

figure

hold on

distance = (1:size(alignedthings,2))*pixtomic;
plot(distance,alignedthings,'Color',[ 0.7 0.9 0.6 ])

avgflur = mean(alignedthings,1);

[fitresult,gof] = createFit(distance,avgflur);

text( 0.5 , 0.8 , ['Sd of Spa2-mCherry peak = ',num2str(fitresult.sd) ,'\mu m' ] , 'Units' , 'Normalized' )

%% functions to fit with


function [fitresult, gof] = createFit(distance, xint)
%CREATEFIT(DISTANCE,XINT)
%  Create a fit.
%
%  Data for 'untitled fit 1' fit:
%      X Input : distance
%      Y Output: xint
%  Output:
%      fitresult : a fit object representing the fit.
%      gof : structure with goodness-of fit info.
%
%  See also FIT, CFIT, SFIT.

%  Auto-generated by MATLAB on 03-Feb-2019 18:50:07


%% Fit: 'untitled fit 1'.
[xData, yData] = prepareCurveData( distance, xint );

% Set up fittype and options.
ft = fittype( 'a*exp(-(distance-u)^2/(2*sd^2)) + c', 'independent', 'distance', 'dependent', 'y' );
opts = fitoptions( 'Method', 'NonlinearLeastSquares' );
opts.Display = 'Off';
opts.Lower = [800 0 0 -Inf];
opts.Upper = [2000 600 max(distance)/3 Inf];
[~,maxInd] = max(xint); %to find a good starting point
opts.StartPoint = [1000 200 distance(maxInd) max(distance)/2];

% Fit model to data.
[fitresult, gof] = fit( xData, yData, ft, opts );

% Plot fit with data.
h = plot( fitresult, xData, yData );
legend off
%legend( h, 'xint vs. distance', 'untitled fit 1', 'Location', 'NorthEast' );
% Label axes
xlabel('Distance')
ylabel Fluor
grid on
axis square
end
